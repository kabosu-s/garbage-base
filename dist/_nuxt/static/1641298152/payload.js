__NUXT_JSONP__("/", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){return {data:[{contents:[{id:"idb8i8zmx1u",createdAt:e,updatedAt:e,publishedAt:e,revisedAt:e,title:"NUXTにかえました！",mainimage:{url:"https:\u002F\u002Fimages.microcms-assets.io\u002Fassets\u002F30dedbc29bbf472a8bd932f7df5e77d6\u002F95a1ea57491b46639e2798e0dfbc1035\u002Fnext.jpg",height:a,width:b},body:"\u003Cp\u003ENUXTにかえました～！\u003Cbr\u003Eほぼmicrocmsのブログに頼りっぱなしでしたが、jamstackになった気がする！\u003C\u002Fp\u003E",tag:[c]},{id:"b49awo370",createdAt:f,updatedAt:f,publishedAt:f,revisedAt:f,title:"制作時メモ【ナビゲーションガードを覚える】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003E前回のマウスストーカー\bをwatchで、監視していたのですが、ナビゲーションガードを使うとよさそうと気づいた！\u003Cbr\u003E\u003Cbr\u003Emountedのなかでこんな感じで…？\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    mounted() {\n        this.$router.beforeEach((to, from, next) =&gt; {\n            this.isOpen = false;\n            next();\n        });\n        this.$router.afterEach((to, from, next) =&gt; {\n            setTimeout(() =&gt; {\n                this.setpointer();\n                this.isOpen = true;\n            }, 600);\n            next();\n        });\n    },\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eついでに、画面遷移時にマウスストーカーが広がるようにしてみました。\u003Cbr\u003Eもすこしうまいことできそう？\u003Cbr\u003E\u003Cbr\u003Eつづきます。\u003C\u002Fp\u003E",tag:[c]},{id:"o23ioitsowxo",createdAt:g,updatedAt:h,publishedAt:g,revisedAt:h,title:"制作時メモ【マウスストーカーを追加】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003E数10年前に流行ってたやつ…なんか最近流行ってますよね～。\u003Cbr\u003Eいらない機能感が甚だしいですが、せっかくのガラクタ置き場なので追加してみます。\u003Cbr\u003E\u003Cbr\u003Eコンポーネントにしてみました。\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;template&gt;\n    &lt;div class=\"mouse-stalker\" :class=\"{ target: set }\"&gt;\n        &lt;span&gt;&lt;\u002Fspan&gt;\n    &lt;\u002Fdiv&gt;\n&lt;\u002Ftemplate&gt;\n\n&lt;script&gt;\nexport default {\n    name: \"MouseStalker\",\n    data() {\n        return {\n            stalker: { x: 0, y: 0 },\n            mouse: { x: 0, y: 0 },\n            mouseStalker: null,\n            targets: null,\n            set: false,\n        };\n    },\n    mounted() {\n        this.setup();\n        document.addEventListener(\"mousemove\", this.mousemove);\n        this.target.addEventListener(\"mouseover\", this.hovertarget);\n        this.target.addEventListener(\"mouseout\", this.leavetarget);\n    },\n    methods: {\n        setup() {\n            this.mouseStalker = document.querySelector(\".mouse-stalker\");\n            this.targets = document.querySelector(\".nav\");\n            this.update();\n        },\n        update() {\n            this.stalker.x += (this.mouse.x - this.stalker.x) * 0.1;\n            this.stalker.y += (this.mouse.y - this.stalker.y) * 0.1;\n            let x = Math.round(this.stalker.x * 10) \u002F 10;\n            let y = Math.round(this.stalker.y * 10) \u002F 10;\n            this.mouseStalker.style.transform =\n                `translate3d(` + x + \"px,\" + y + \"px, 0)\";\n            requestAnimationFrame(this.update);\n        },\n        mousemove(e) {\n            this.mouse.x = e.clientX;\n            this.mouse.y = e.clientY;\n        },\n        hovertarget() {\n            this.set = true;\n        },\n        leavetarget() {\n            this.set = false;\n        },\n    },\n};\n&lt;\u002Fscript&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n.mouse-stalker {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 1px;\n    height: 1px;\n    position: fixed;\n    top: 0;\n    left: 0;\n    z-index: 10000;\n    pointer-events: none;\n    mix-blend-mode: exclusion;\n    &gt; span {\n        width: 10px;\n        height: 10px;\n        border-radius: 50%;\n        background: $c_base;\n        border: 1px solid $c_base;\n        flex-shrink: 0;\n        transition: all 0.3s ease-in;\n    }\n    &amp;.target &gt; span {\n        width: 40px;\n        height: 40px;\n        background: transparent;\n    }\n}\n&lt;\u002Fstyle&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eリンクにホバーしたときの見た目を変えようと思ったのですが…複数のセレクタを選択できなかった…。\u003Cbr\u003Eので、宿題にします。\u003Cbr\u003E\u003Cbr\u003Eちなみにほんとに作ろうと思ってるのは、また今度。\u003Cbr\u003E\u003Cbr\u003E（9\u002F18追記）\u003Cbr\u003Eこちらを参考に直してみました。\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fmyscreate.com\u002Fdom-acquisition\u002F\" target=\"_blank\" rel=\"noopener noreferrer\"\u003E[JS]getElementByIdでは上手くいくのにgetElementsByClassNameでは上手くDOM操作が出来ないとき\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003E複数セレクタを取得した場合はHTMLElementではなく、HTMLCollectionとやらになるそうで…？\u003Cbr\u003E一個、一個をforで回して…\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E            this.targets = document.getElementsByTagName(\"a\");\n            this.targets.forEach((target) =&gt; {\n                target.addEventListener(\"mouseover\", this.hovertarget, false);\n                target.addEventListener(\"mouseout\", this.leavetarget, false);\n            });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eで、複数セレクタは取れたのですが…関数実行後に読み込まれたリンクたちが無視されている。\u003Cbr\u003Eなるほど…？\u003Cbr\u003E\u003Cbr\u003Eルーターを監視して、画面を切り替えたら↑を実行させてみた。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    watch: {\n        $route: function () {\n                this.setpointer();\n        },\n    },\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cbr\u003Eなんか違う気がするけど一旦こちらで\u003Cbr\u003E\u003C\u002Fp\u003E",tag:[c]},{id:"i6hp7xqes_6u",createdAt:i,updatedAt:j,publishedAt:i,revisedAt:j,title:"制作時メモ【前後の記事を取得してみる】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003E前後の記事のリンクを記事の下に貼りたいですよね。\u003Cbr\u003E貼りたいです。\u003Cbr\u003E\u003Cbr\u003E調べたら公式で解説されてました。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fdocument.microcms.io\u002Ffaq\u002Fget-previous-or-next\" target=\"_blank\" rel=\"noopener noreferrer\"\u003E一つ前 \u002F 一つ後ろのコンテンツはどのように取得すれば良いですか？\u003C\u002Fa\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E\u002F\u002Fコンテンツ情報を取得しているところ\nconst { contents } = await client\n  .get({\n    endpoint: 'blog',\n    queries: {limit: 1000, fields: 'id,title'} \u002F\u002F1000件、タイトルとIDだけを取得する\n  })\n\nconst index = contents.findIndex((content) =&gt; content.id === slug); \u002F\u002F取得情報から自分のIDを満たす最初の要素の位置をかえす\nconst prev = contents[index - 1]; \nconst next = contents[index + 1];\nconsole.log([prev, next]);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Ejs弱者なので…だいぶ悩みましたが…、頑張って、解読して…\u003Cbr\u003E\u003Cbr\u003E\u003Ccode\u003EfindIndex()\u003C\u002Fcode\u003E\u003Cbr\u003E\u003Cbr\u003Eこのメソッドでつまずいたので調べます。\u003Cbr\u003E調べると…\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003EfindIndex() メソッドは、配列内の指定されたテスト関数を満たす最初の要素の位置を返します。テスト関数を満たす要素がない場合を含め、それ以外の場合は -1 を返します。\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fja\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FfindIndex\" target=\"_blank\" rel=\"noopener noreferrer\"\u003EArray.prototype.findIndex()\u003C\u002Fa\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cstrong\u003E取得情報から自分のIDを満たす位置をかえす\u003C\u002Fstrong\u003E\u003Cbr\u003Eということかな。\u003Cbr\u003E\u003Cbr\u003E一定の記事を取得→今の記事IDの位置を探す→+-1して前後の記事を代入\u003Cbr\u003Eという流れのようでした。\u003Cbr\u003E\u003Cbr\u003Eというわけで、こんな感じのメソッドで作ってみます。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Fview\u002FArticleDetail.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Eexport default {\n    data() {\n        return {\n            prev: {},\n            next: {},\n        };\n    },\n    methods: {\n        async getPrevNext() {\n            const response = await axios.get( \u002F\u002Fデータを取得\n                process.env.VUE_APP_X_API_URL_BLOG +\n                    \"?limit=100\" + \u002F\u002Fとりあえず100件\n                    \"&amp;fields=id,title,mainimage\", \u002F\u002F画像も出したいのでimgも\n                {\n                    headers: {\n                        \"X-API-KEY\": process.env.VUE_APP_X_API_KEY,\n                    },\n                }\n            );\n            const contents = response.data.contents;\n            const index = contents.findIndex(\n                (content) =&gt; content.id === this.$route.params.id \u002F\u002F取得したデータから自分のIDの位置を探す\n            );\n            this.prev = contents[index + 1]; \u002F\u002F前の記事\n            this.next = contents[index - 1]; \u002F\u002F後の記事\n        },\n    },\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eなんかprevとnextが公式と+-が逆でした。\u003Cbr\u003E…あれ？ prevが前で、nextが次…よね？\u003Cbr\u003E\u003Cbr\u003Eとはいえ、うまく行った？ぽい！\u003Cbr\u003Eつづきます\u003C\u002Fp\u003E",tag:[]},{id:"tah-aijp77",createdAt:"2021-08-16T13:26:33.776Z",updatedAt:k,publishedAt:"2021-08-16T13:27:01.657Z",revisedAt:k,title:"制作時メモ【MicroCMSから記事呼び出し】",mainimage:{url:d,height:a,width:b},body:"\u003Ch2 id=\"hb42c7b61a3\"\u003EMicro CMSって？\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cbr\u003Eデータベースとか、さっぱりわからんデザイナーですが…、せっかくVueやるしデータのやり取りしたいよね。\u003Cbr\u003Eと思ってた時にヘッドレスCMSを知りまして、日本製でとっつきやすそうだったMicro CMSを使ってみることにしました。\u003Cbr\u003E\u003Cbr\u003EヘッドレスCMSについて、詳しくはMicro CMSさんの公式のブログがとても参考になりましたのでそちらにおまかせします。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fblog.microcms.io\u002Fvs-wordpress\u002F\" target=\"_blank\" rel=\"noopener noreferrer\"\u003EヘッドレスCMSって何？WordPressとの違いや特徴、DXで推進される要因を解説\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h75ff0529eb\"\u003EMicro CMSのAPIを使うために環境変数をつくる\u003C\u002Fh2\u003E\u003Cp\u003E扱う前の下準備。\u003Cbr\u003E.env.localをプロジェクト直下に作って、API_KEYを書く。\u003Cbr\u003EファイルからAPIを呼び出す時はこちらを参照するようにする。\u003Cbr\u003E\u003Cbr\u003EこれだとバンドルされたJSファイルにはAPIキーの値が含まれるらしい…。\u003Cbr\u003E対策を考える…。どこかで…（もういっそ\u003Cspan style=\"color:#333333\"\u003ENuxt.js\u003C\u002Fspan\u003E勉強して乗り換えようかな。）\u003Cbr\u003E\u003Cbr\u003E.env.local\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003EVUE_APP_X_API_URL_BLOG='xxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\nVUE_APP_X_API_KEY='xxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h84009ac2e9\"\u003EAPIと非同期通信する\u003C\u002Fh2\u003E\u003Cp\u003Eaxiosで非同期通信しようと思うのでインストール。\u003Cbr\u003E\u003Cbr\u003Eターミナル・プロジェクトルート直下\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E$ npm install axios --save\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E試しによんでみる。\u003Cbr\u003EHome.vueをこんなかんじに。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Fviews\u002FHHome.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;template&gt;\n    &lt;div class=\"article_list\"&gt;\n        &lt;div v-for=\"article in articles\" :key=\"article.id\"&gt;\n            &lt;img :src=\"article.mainimage.url\" \u002F&gt;\n            &lt;h2&gt;{{ article.title }}&lt;\u002Fh2&gt;\n        &lt;\u002Fdiv&gt;\n    &lt;\u002Fdiv&gt;\n&lt;\u002Ftemplate&gt;\n\n&lt;script&gt;\nimport axios from \"axios\";\nexport default {\n    data() {\n        return {\n            articles: [],\n        };\n    },\n    created() {\n        this.getPosts();\n    },\n    methods: {\n        async getPosts() {\n            const response = await axios.get(\n                process.env.VUE_APP_X_API_URL_BLOG,\n                {\n                    headers: {\n                        \"X-API-KEY\": process.env.VUE_APP_X_API_KEY,\n                    },\n                }\n            );\n            this.articles = response.data.contents;\n        },\n    },\n};\n&lt;\u002Fscript&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Emicro.cmsで書いた記事が読み込まれました！\u003Cbr\u003E\u003Cbr\u003E\u003Cimg src=\"https:\u002F\u002Fimages.microcms-assets.io\u002Fassets\u002F30dedbc29bbf472a8bd932f7df5e77d6\u002Fb917a9cc73fa4cd9aeb99640cc7760a3\u002Fimg.jpg\" alt=\"\"\u003E\u003Cbr\u003E\u003Cbr\u003Eつづく\u003C\u002Fp\u003E",tag:[c]},{id:"bbuoqcy6mc",createdAt:"2021-08-15T04:49:21.317Z",updatedAt:l,publishedAt:"2021-08-15T09:33:36.926Z",revisedAt:l,title:"制作時メモ【いまさらMPA化！】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003ESPA（シングルページアプリケーション）だと、色々作りたい時に手間だったので\u003Cbr\u003EMPA（マルチページアプリケーション）にしてみます！\u003Cbr\u003E\u003Cbr\u003Eこちらをめちゃめちゃ参考にしました。\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fqiita.com\u002Fkamicop\u002Fitems\u002Fc5c0917ed226234ee288\" target=\"_blank\" rel=\"noopener noreferrer\"\u003EVue CLI 3でSPAではなくMPA(複数エントリーポイント)のプロジェクトを作成する\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003Eまあ、上のページからほぼなにもかえてないのですが…\u003Cbr\u003E気をつけたのは…\u003Cbr\u003E\u003Cbr\u003Eモジュールを追加すること\u003Cbr\u003E\u003Cbr\u003Eターミナル。プロジェクトルート直下で\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E$ npm install --save-dev html-webpack-plugin preload-webpack-plugin\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eディレクトリの構成はこんな感じ\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E└── src\n&nbsp; &nbsp; ├── assets\n&nbsp; &nbsp; │&nbsp; &nbsp;└── logo.png\n&nbsp; &nbsp; ├── components\n&nbsp; &nbsp; │&nbsp; &nbsp;└── Footer.vue\n&nbsp; &nbsp; │&nbsp; &nbsp;└── Header.vue\n&nbsp; &nbsp; ├── entry-point\n&nbsp; &nbsp; │&nbsp; &nbsp;└── lab\n&nbsp; &nbsp; │&nbsp; &nbsp; &nbsp; &nbsp;└── Lab.vue\n&nbsp; &nbsp; │&nbsp; &nbsp; &nbsp; &nbsp;└── main.js\n&nbsp; &nbsp; │&nbsp; &nbsp;└── top\n&nbsp; &nbsp; │&nbsp; &nbsp; &nbsp; &nbsp;└── Top.vue\n&nbsp; &nbsp; │&nbsp; &nbsp; &nbsp; &nbsp;└── main.js\n&nbsp; &nbsp; ├── main.js\n&nbsp; &nbsp; ├── routersr\n&nbsp; &nbsp; │&nbsp; &nbsp;└── index.js\n&nbsp; &nbsp; └── views\n&nbsp; &nbsp; &nbsp; &nbsp; ├── About.vue\n&nbsp; &nbsp; &nbsp; &nbsp; └── Home.vue\n└──vue.config.js\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Evue.config.js\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Emodule.exports = {\n  pages: {\n    top: {\n      entry: 'src\u002Fentry-point\u002Ftop\u002Fmain.js', \n      template: 'public\u002Findex.html', \n      filename: 'index.html', \n    },\n    lab: {\n      entry: 'src\u002Fentry-point\u002Flab\u002Fmain.js',\n      title: 'LAB', \u002F\u002Frouterのmetaを参照しない\n      template: 'public\u002Flab.html',\n      filename: 'lab.html',\n    },\n  },\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Erouterのパス\u003Cbr\u003E\u002Fsrc\u002Fentry-point\u002Ftop\u002Fmain.js\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Eimport { createApp } from 'vue'\nimport Top from '.\u002FTop.vue'\nimport router from '@\u002Frouter'\n\ncreateApp(Top).use(router).mount('#app')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cbr\u003Eデプロイ先のnetlifyでのリダイレクト設定\u003Cbr\u003Eリダイレクトの話はこちらを参照にしました。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fblog.microcms.io\u002Fnetlify-redirect\u002F\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ENetlifyでリダイレクトを実装する\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003E_redirects\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E#labにアクセスされた時にリダイレクト\n\u002Flab&nbsp; &nbsp; \u002Flab.html&nbsp; &nbsp;200\n#他は全部indexにとばす\n\u002F*&nbsp; &nbsp; \u002Findex.html&nbsp; &nbsp;200\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fgarbage-base.netlify.app\u002Flab\" target=\"_blank\" rel=\"noopener noreferrer\"\u003Ehttps:\u002F\u002Fgarbage-base.netlify.app\u002Flab\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003Eにアクセスすることができました！\u003Cbr\u003Eあ、いまのとこaと表示されてるだけです\u003Cbr\u003E\u003Cbr\u003Eつづきます\u003C\u002Fp\u003E",tag:[c]},{id:"hd6jiqwd_t",createdAt:m,updatedAt:n,publishedAt:m,revisedAt:n,title:"制作時メモ 【Not Found \u002F ページ遷移時の動作】",mainimage:{url:d,height:a,width:b},body:"\u003Ch2 id=\"h9ddf404540\"\u003ENot Foundページ\u003C\u002Fh2\u003E\u003Cp\u003ENot foundを作ります。\u003Cbr\u003E仕組みはRouterで予め設定していない。予期しない値が呼ばれたらnotfound.vueを呼び出すとするだけ。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Frouter\u002Findex.js\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Econst routes = [\n--略--\n  {\n    path: '\u002F:pathMatch(.*)*',\n    name: 'Notfound',\n    component: () =&gt; import('..\u002Fviews\u002FNotFound.vue'),\n    meta: { title: 'Not Found', desc: 'ページが見つかりません' },\n  }\n]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eググっていて詰まったところは、ルートを上から順に書いていって、上までの候補にパスが該当しない場合すべてという意味で\u003Cbr\u003E\u003Ccode\u003Epath: '\u002F*'\u003C\u002Fcode\u003Eと書けばいいと書いてあったけど、うまくいかなかった。\u003Cbr\u003E\u003Cbr\u003E3系だと\u003Ccode\u003E path: '\u002F:pathMatch(.\u003C\u002Fcode\u003E\u003Cem\u003E\u003Ccode\u003E)\u003C\u002Fcode\u003E\u003C\u002Fem\u003E\u003Ccode\u003E',\u003C\u002Fcode\u003Eとする必要があるそうです。ほーん。\u003Cbr\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"hbcf9481cfc\"\u003Eページ遷移時の動き\u003C\u002Fh2\u003E\u003Cp\u003Eページ遷移ぽい動きをしたときにページの位置が中途半端（今の位置を維持している…）のでトップに移動したい。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Frouter.vuejs.org\u002Fja\u002Fguide\u002Fadvanced\u002Fscroll-behavior.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003Eスクロールの振る舞い\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003E上記に書いてあったのをそのままやってみたけど\u003Cspan style=\"color:#333333\"\u003Eうまくいかなかった。\u003C\u002Fspan\u003E\u003Cbr\u003E\u003Cbr\u003E同じように悩んでいる人がいらしたのでガッツリ拝借します。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fwww.nanatsu.jp\u002F?p=484\" target=\"_blank\" rel=\"noopener noreferrer\"\u003EVue-CLI(Vue3.x)でページ遷移時にトップへ移動する\u003C\u002Fa\u003E\u003Cbr\u003E\u003Cbr\u003Eその後色々書き換えてみて。\u003Cbr\u003E\u003Cbr\u003E \u003Ccode\u003Ereturn { x: 0, y: 0 }\u003C\u002Fcode\u003Eが  \u003Ccode\u003Ereturn { top: 0 }\u003C\u002Fcode\u003Eだったら中に直接書いてもうまくいったけど、\u003Cbr\u003E外に出したほうが見やすいので外に出す方向でいくことにしました。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Frouter\u002Findex.js\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E\u002F\u002Fページ遷移時にページ先頭に移動する\nconst scrollBehavior = (to, from, savedPosition) =&gt; {\n  if (savedPosition) {\n    return savedPosition;\n  } else {\n    return { top: 0 }\n  }\n};\n\n\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n  scrollBehavior,\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E",tag:[c]},{id:"imtc6j-g3e",createdAt:"2021-08-13T08:39:19.567Z",updatedAt:o,publishedAt:"2021-08-13T08:56:10.309Z",revisedAt:o,title:"制作時メモ【viewsとcomponentsフォルダへの区分けについて】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003Eフロント側のviewsとcomponents周りを整える\u003Cbr\u003E両方のフォルダに.vueファイルがあるので、何をどっちに作るべきなのか迷った。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h405ef6b021\"\u003E区分けルール\u003C\u002Fh2\u003E\u003Ch3 id=\"h628b44aa83\"\u003Eviewsフォルダはルーティングに登録されるもの\u003C\u002Fh3\u003E\u003Cp\u003Eviewsフォルダに置かれているコンポーネントは、\u003Cbr\u003Eルーティングを構成する\u003Ccode\u003Esrc\u002Frouter\u002Findex.js\u003C\u002Fcode\u003Eにimportされるコンポーネントとする。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch3 id=\"h2510727db6\"\u003Ecomponentsフォルダは再利用可能で、ページを構成する部品\u003C\u002Fh3\u003E\u003Cp\u003Ecomponentsフォルダのコンポーネントはルートとして使用されないので、\u003Cbr\u003E再利用可能な部品として扱かえるものをおく。\u003Cbr\u003E\u003Cbr\u003Eといわけで。さっそく\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h9195544db1\"\u003Eヘッダーフッターをcomponentsに作り読み込んでみる\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cbr\u003Eファイルの構成はこんな感じ\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E└── src\n    ├── App.vue\n    ├── assets\n    │   └── logo.png\n    ├── components\n    │   └── Footer.vue\n    │   └── Header.vue\n    ├── main.js\n    ├── routersr\n    │   └── index.js\n    └── views\n        ├── About.vue\n        └── Home.vue\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cbr\u003EApp.vueにHeaderとFooterと\u003Cs\u003Eルート時の中身（Home）\u003C\u002Fs\u003Eをインポートする。\u003Cbr\u003E中身はRouterで制御するので、\u003Cspan style=\"color:#33cc33\"\u003Erouter-view\u003C\u002Fspan\u003Eを読み込むことにする。（cliで作ったときからそうだったのでそれを活かします。）\u003Cbr\u003E\u003Cbr\u003EHeader.vueとFooter.vueをApp.vueにインポートして、コンポーネントとして登録する。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002FApp.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;script&gt;\n\u002F\u002Fインポート   @ is an alias to \u002Fsrc（@は\u002Fsrt\u002Fのエイリアス）だそうです。←書いてあった。\nimport Header from \"@\u002Fcomponents\u002FHeader.vue\";\nimport Footer from \"@\u002Fcomponents\u002FFooter.vue\";\n\nexport default {\n    components: { \u002F\u002Fここで読み込んだファイルを設定する\n        Header,\n        Footer,\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E↑で設定したので、テンプレート側ではこんなかんじで呼び出せる。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002FApp.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;template&gt;\n    &lt;Header \u002F&gt;\n    &lt;router-view \u002F&gt; \u002F\u002Fはじめから書いてあった。Routerを呼び出してるぽい\n    &lt;Footer \u002F&gt;\n&lt;\u002Ftemplate&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003EHeader.vueやFooter.vueの中身はwpやcakeで作るときとおんなじ感じでコーディングする。\u003Cbr\u003E例えばこんな感じ。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Fcomponents\u002FFooter.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;template&gt;\n        &lt;footer&gt;© Garbage Base.&lt;\u002Ffooter&gt;\n&lt;\u002Ftemplate&gt;\n\n&lt;style lang=\"scss\" scoped&gt; \u002F\u002Fscss形式でかける。scopedと↑のテンプレートだけにスタイルが当たる。\nfooter {\n    width: 100%;\n    text-align: center;\n    font-size: 0.9rem;\n    color: #222;\n    margin: auto;\n    border-top: 1px solid #444;\n    padding: 10px 1%;\n}\n&lt;\u002Fstyle&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eつづきます\u003C\u002Fp\u003E",tag:[c]},{id:"m708qzbres-w",createdAt:"2021-08-09T05:47:32.622Z",updatedAt:p,publishedAt:"2021-08-13T08:17:56.660Z",revisedAt:p,title:"制作時メモ【titleとdescriptionをページ毎に設定する】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003Eやりたいこと。\u003Cbr\u003Eページ毎にタイトルとディスクリプションが変わるようにする。\u003Cbr\u003E\u003Cbr\u003Erouter周りを調整して、実現させようと思います。\u003Cbr\u003E\u003Cbr\u003Eこちらの記事からコードガッツリいただきました。\u003Cbr\u003E\u003Cbr\u003E\u003Ca href=\"https:\u002F\u002Fqiita.com\u002Fshizen-shin\u002Fitems\u002F1fc2d1f5b4add2c0ed2c\" target=\"_blank\" rel=\"noopener noreferrer\"\u003E【Vue.js】Vue CLIで作成したページのtitleとdescriptionを変更する方法\u003C\u002Fa\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h62d7c782a4\"\u003Erouterにmetaフィールドを追加\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003E下記のmeta部分を記述。\u003C\u002Fspan\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003E\u002Fsrc\u002Frouter\u002Findex.js\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Econst routes = [\n  {\n    path: '\u002F',\n    name: 'Home',\n    component: Home,\n    meta: { title: 'ページタイトル', desc: 'ディスクリプションを記述' } \u002F\u002F追加\n  }\n]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h86d7ef4dbe\"\u003Eapp.vueにtitleとdescriptionをセットするメソッドを追加\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003Emethodsオプションに下記を記述。\u003C\u002Fspan\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003E↑プロパティ（タイトルやディスクリプション）へのアクセス方法は\u003C\u002Fspan\u003E\u003Ccode\u003Eルートインスタンス.meta.設定した変数名\u003C\u002Fcode\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003E\u002Fsrc\u002FApp.vue\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    methods: {\n        \u002F\u002Ftitleをセットするメソッド\n        createTitleDesc: function (routeInstance) {\n            \u002F\u002F引数でrouteインスタンスを渡すmountedオプションで代入\n            \u002F\u002F route.meta.titleで設定したtitleを取得\n            if (routeInstance.meta.title) {\n                \u002F\u002Ftitleが設定されていれば\n                const setTitle = routeInstance.meta.title + \" | Garbage Base\";\n                document.title = setTitle;\n            } else {\n                \u002F\u002Ftitleが設定されていない時\n                document.title = \"Garbage Base\";\n            }\n        \u002F\u002Fdescriptionを判定\n            if (routeInstance.meta.desc) { \u002F\u002Fdescが設定されていれば\n                const setDesc = routeInstance.meta.desc;\n                document.querySelector(\"meta[name='description']\").setAttribute('content', setDesc)\n            } else { \u002F\u002Fdescが設定されていない時\n                document.querySelector(\"meta[name='description']\").setAttribute('content', 'description is not set')\n            }\n        },\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h80f2ed8b8b\"\u003Emountedオプションをセット\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cspan style=\"color:#333333\"\u003E\u002Fsrc\u002FApp.vue\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    mounted: function () {\n        const routeInstance = this.$route; \u002F\u002Frouteインスタンス（$rounte）を変数(routeInstance)に代入\n        this.createTitleDesc(routeInstance); \u002F\u002F実行。method呼ぶときはthis.\n    },\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"ha1ac1a966d\"\u003Ewatchオプションをセット\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cspan style=\"color:#333333\"\u003Etitleやdescriptionに変更があった場合に、変更内容を自動反映するようwatchオプションを追加する。\u003C\u002Fspan\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cspan style=\"color:#333333\"\u003E\u002Fsrc\u002FApp.vue\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    watch: {\n        $route(routeInstance) {\n            this.createTitleDesc(routeInstance);\n        },\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"h25b67806e4\"\u003Epubulic&gt;index.htmlにdescription属性を追加\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cbr\u003E書き換え対象のDOMを記述する\u003Cbr\u003E以下の記述で上記タグを参照することができる。\u003Ccode\u003Edocument.querySelector(\"meta[name='description']\")\u003C\u002Fcode\u003E\u003Cbr\u003E\u003Cbr\u003E\u002Fpublic\u002Findex.html\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    &lt;meta name=\"description\"&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003E完了！\u003Cbr\u003E\u003Cbr\u003E…ブログ個別記事は…どうしたらいい？\u003Cbr\u003Eひとまず記事側のvue\bで直接書き換えてみました。\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Fviews\u002FArticleDetail.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E    methods: {\n        async getArticle() {\n        \u002F\u002F略           \n         \u002F\u002Ftitleを書き換える\n         document.title = this.article.title;\n        },\n   }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Eつづきます\u003C\u002Fp\u003E",tag:[c]},{id:"zsob6xf4uii",createdAt:"2021-08-08T06:21:05.510Z",updatedAt:q,publishedAt:"2021-08-08T09:41:40.625Z",revisedAt:q,title:"制作時メモ【sassの設定】",mainimage:{url:d,height:a,width:b},body:"\u003Cp\u003Eプロジェクトができたので…色々すすめます。\u003Cbr\u003E\u003C\u002Fp\u003E\u003Ch2 id=\"hcac6f97b18\"\u003E設定用のsassをグローバルで読み込む\u003C\u002Fh2\u003E\u003Cp\u003Eとりあえず…sassのセッティングとかmixinとか全体で使えるようにしたい。\u003Cbr\u003Esass-loaderをインストール\u003Cbr\u003E\u003Cbr\u003Eターミナルのプロジェクトルート直下に移動して\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E$ npm install --save-dev node-sass sass-loader\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Evue.config.jsをプロジェクトルート直下に作ってグローバルで読み込めば設定した変数とかmixinをそれぞれのファイルから呼び出せるようになる\u003Cbr\u003E\u003Cbr\u003Evue.config.js\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Emodule.exports = {\n  css: {\n    loaderOptions: {\n      scss: {\n        prependData: '@import \"@\u002Fassets\u002Fsass\u002Fprepends.scss\";'\n      }\n    }\n  }\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cbr\u003Emixinが使える！\u003Cbr\u003E\u003Cbr\u003E\u002Fsrc\u002Fcomponents\u002FHeader.vue\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E&lt;style lang=\"scss\" scoped&gt;\nheader {\n    border-bottom: 1px dashed #666666;\n    display: flex;\n    flex-flow: row nowrap;\n    height: 100px;\n    justify-content: space-between;\n    padding: 10px 1%;\n    position: relative;\n    width: 100%;\n    @include mq767 { \u002F\u002Fメディアクエリのmixin\n        height: 60px;\n        padding: 0 1%;\n    }\n}\n&lt;\u002Fstyle&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eつづきます\u003C\u002Fp\u003E",tag:[c]}],totalCount:11,offset:0,limit:10,page:"1"}],fetch:{},mutations:void 0}}(600,1200,"WEB","https:\u002F\u002Fimages.microcms-assets.io\u002Fassets\u002F30dedbc29bbf472a8bd932f7df5e77d6\u002Feeac577d4a4541458a68d4fa8714c847\u002Fvue_back.jpg","2022-01-04T08:46:23.996Z","2021-09-20T13:54:03.958Z","2021-09-12T12:54:50.884Z","2021-09-23T08:23:36.648Z","2021-08-18T13:02:04.579Z","2021-08-18T13:34:20.166Z","2021-08-18T12:04:35.062Z","2021-08-18T11:48:23.762Z","2021-08-13T09:06:52.403Z","2021-08-18T11:41:57.202Z","2021-08-18T11:34:24.184Z","2021-08-18T11:39:51.069Z","2021-08-18T11:35:49.924Z")));